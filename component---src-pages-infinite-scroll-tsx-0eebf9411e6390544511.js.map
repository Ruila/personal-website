{"version":3,"file":"component---src-pages-infinite-scroll-tsx-0eebf9411e6390544511.js","mappings":"0LAGaA,EAA0C,WACrD,OAA0BC,EAAAA,EAAAA,UAAS,QAA5BC,EAAP,KAAcC,EAAd,KACA,GAAoCF,EAAAA,EAAAA,UAAS,GAAtCG,EAAP,KAAmBC,EAAnB,KAEA,ECLoC,SAACH,EAAeE,GACpD,OAA8BH,EAAAA,EAAAA,WAAS,GAAhCK,EAAP,KAAgBC,EAAhB,KACA,GAA0BN,EAAAA,EAAAA,WAAS,GAA5BO,EAAP,KAAcC,EAAd,KACA,GAAwBR,EAAAA,EAAAA,UAAwB,IAAzCS,EAAP,KAAaC,EAAb,KACA,GAA8BV,EAAAA,EAAAA,WAAS,GAAhCW,EAAP,KAAgBC,EAAhB,KACMC,EAAW,IAAIC,MAAM,IAAIC,KAAK,SAoBpC,OAnBAC,EAAAA,EAAAA,YAAU,WACRN,EAAQ,MACP,CAACT,KAEJe,EAAAA,EAAAA,YAAU,WACRV,GAAW,GACXE,GAAS,GACT,IAAMS,EAAQC,YAAW,WACvBR,GAAQ,SAAAS,GACN,wBAAWA,IAAX,OAAyBN,OAE3BD,GAAW,GACXN,GAAW,KACV,KACH,OAAO,WACLc,aAAaH,MAEd,CAAChB,EAAOE,IAEJ,CAAEE,QAAAA,EAASE,MAAAA,EAAOE,KAAAA,EAAME,QAAAA,GDpBWU,CACxCpB,EACAE,GAFMM,EAAR,EAAQA,KAAME,EAAd,EAAcA,QAASN,EAAvB,EAAuBA,QAASE,EAAhC,EAAgCA,MAK1Be,GAAWC,EAAAA,EAAAA,UACXC,GAAiBC,EAAAA,EAAAA,cACrB,SAAAC,GACMrB,IAGAiB,EAASK,SACXL,EAASK,QAAQC,aAEnBN,EAASK,QAAU,IAAIE,sBAAqB,SAAAC,GACtCA,EAAQ,GAAGC,gBAAkBpB,GAC/BP,GAAc,SAAA4B,GAAc,OAAIA,EAAiB,QAGjDN,GACFJ,EAASK,QAAQM,QAAQP,MAG7B,CAACrB,EAASM,IAQZ,OACE,uBAAKuB,UAAU,kDACb,yBACEA,UAAU,gFACVC,KAAK,OACLC,MAAOnC,EACPoC,YAAY,kBACZC,SAZN,SAAsBC,GACpBrC,EAASqC,EAAEC,OAAOJ,OAClBhC,EAAc,MAYXK,EAAKgC,KAAI,SAACC,EAAMC,GACf,OAAIlC,EAAKmC,OAAS,IAAMD,EAEpB,uBACET,UAAU,qFACVW,IAAKrB,EACLsB,IAAKH,GAHP,aAUA,uBACET,UAAU,qFACVY,IAAKH,GAEJD,MAKT,2BAAMrC,GAAW,cACjB,2BAAME,GAAS,WE/DrB,EAJoD,WAClD,OAAO,gBAACR,EAAD","sources":["webpack://my-gatsby-site/./src/components/infinite-scroll/InfiniteScroll.tsx","webpack://my-gatsby-site/./src/components/infinite-scroll/useInfiniteScrollQuery.ts","webpack://my-gatsby-site/./src/pages/infinite-scroll.tsx"],"sourcesContent":["import React, { useState, useRef, useCallback } from \"react\"\nimport { useInfiniteScrollQuery } from \"./useInfiniteScrollQuery\"\n\nexport const InfiniteScroll: React.FunctionComponent = () => {\n  const [query, setQuery] = useState(\"test\")\n  const [pageNumber, setPageNumber] = useState(1)\n\n  const { data, hasMore, loading, error } = useInfiniteScrollQuery(\n    query,\n    pageNumber\n  )\n\n  const observer = useRef<IntersectionObserver>()\n  const lastElementRef = useCallback(\n    node => {\n      if (loading) {\n        return\n      }\n      if (observer.current) {\n        observer.current.disconnect()\n      }\n      observer.current = new IntersectionObserver(entries => {\n        if (entries[0].isIntersecting && hasMore) {\n          setPageNumber(prevPageNumber => prevPageNumber + 1)\n        }\n      })\n      if (node) {\n        observer.current.observe(node)\n      }\n    },\n    [loading, hasMore]\n  )\n\n  function handleSearch(e: React.ChangeEvent<HTMLInputElement>) {\n    setQuery(e.target.value)\n    setPageNumber(1)\n  }\n\n  return (\n    <div className=\"flex flex-col justify-center items-center pt-4\">\n      <input\n        className=\"w-[250px] shadow-lg border-[#000] border-[1px] p-4 border-solid rounded-[5px]\"\n        type=\"text\"\n        value={query}\n        placeholder=\"Input something\"\n        onChange={handleSearch}\n      />\n      {data.map((item, index) => {\n        if (data.length - 1 === index) {\n          return (\n            <div\n              className=\"my-2 w-[250px] shadow-lg border-[#000] border-[1px] border-solid rounded-[5px] p-2\"\n              ref={lastElementRef}\n              key={index}\n            >\n              Last Node\n            </div>\n          )\n        } else {\n          return (\n            <div\n              className=\"my-2 w-[250px] shadow-lg border-[#000] border-[1px] rounded-[5px] border-solid p-2\"\n              key={index}\n            >\n              {item}\n            </div>\n          )\n        }\n      })}\n      <div>{loading && \"Loading...\"}</div>\n      <div>{error && \"Error\"}</div>\n    </div>\n  )\n}\n","import { useEffect, useState } from \"react\"\n\nexport const useInfiniteScrollQuery = (query: string, pageNumber: number) => {\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState(false)\n  const [data, setData] = useState<Array<string>>([])\n  const [hasMore, setHasMore] = useState(false)\n  const mockData = new Array(60).fill(\"hello\")\n  useEffect(() => {\n    setData([])\n  }, [query])\n\n  useEffect(() => {\n    setLoading(true)\n    setError(false)\n    const timer = setTimeout(() => {\n      setData(prevBooks => {\n        return [...prevBooks, ...mockData]\n      })\n      setHasMore(true)\n      setLoading(false)\n    }, 3000)\n    return () => {\n      clearTimeout(timer)\n    }\n  }, [query, pageNumber])\n\n  return { loading, error, data, hasMore }\n}\n","import React from \"react\"\nimport { InfiniteScroll } from \"../components/infinite-scroll/InfiniteScroll\"\n\nconst InfiniteScrollPage: React.FunctionComponent = () => {\n  return <InfiniteScroll />\n}\n\nexport default InfiniteScrollPage\n"],"names":["InfiniteScroll","useState","query","setQuery","pageNumber","setPageNumber","loading","setLoading","error","setError","data","setData","hasMore","setHasMore","mockData","Array","fill","useEffect","timer","setTimeout","prevBooks","clearTimeout","useInfiniteScrollQuery","observer","useRef","lastElementRef","useCallback","node","current","disconnect","IntersectionObserver","entries","isIntersecting","prevPageNumber","observe","className","type","value","placeholder","onChange","e","target","map","item","index","length","ref","key"],"sourceRoot":""}